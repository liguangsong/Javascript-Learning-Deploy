不论我们前面讲到的for, if等语句还是function，他们都有一个特点，就是后面有一对{}比如

    for(var i = 0; i < items.length; i++){
        //请脑补“{”和“}”之间有代码
    }

    if(some_express){
        //请脑补“{”和“}”之间有代码
    }
    
    function(param1){
        //请脑补“{”和“}”之间有代码
    }
    
所有{}包起来的代码，都可以称之为 **“代码块”** ， 英文名叫Block。

每个代码块都有一个自己的作用域，作用域决定了变量能否被访问（不论读取变量还是修改变量）。

访问的规则大概是这样的：

[1] 在最上层没有任何{}包裹的作用域为顶层作用域，声明的变量是哪里都可以访问的，如：
 
    var x = 5;
    if(x>0){ //可以访问
        x = 6; //可以访问
    }
    
    function print_x(){
        console.log(x); //也可以访问
    }

[2] 任何一个代码块，{}之间的代码区域称之为它的作用域，每一对大括号括起来的代码块里声明的变量，只能在这个代码块的作用域里访问，不过在js里是不具备这个能力的。
但是为了建立起正确的思维观，我们还是要讲讲块级作用域。虽然语言不支持，但我们人不要跨越块级作用域，这是一个基本素质，会极大的减少Bug发生率。

    if(true) {
        var x = 5;
        console.log(x); //可以访问
    }
    console.log(x); //其他语言里无法访问，但是在js里可以，但是我们就不要去访问了。
    
这是一个语言缺陷（当初不知道是不是作为功能设计的……），在新版js（所谓的EcmaScript6）中加入了let关键字，使用let关键字声明的变量就会遵守块级作用域的规则了。


    if(true) {
        let x = 5;
        console.log(x); //可以访问
    }
    console.log(x); //无法访问，报异常： Uncaught ReferenceError: x is not defined

    

[3] 代码块是有层级的，在一个代码块里写的新的代码块，后者是前者的子作用域
    
    if(true){
        //相对于下面的代码块的父作用域
        var x = 5;
        if(x > 0){
            //子作用域
        }
    }

[4] 子作用域可以访问父作用域的变量，但是父作用域无法访问子作用域的变量

    if(true){
        var x = 5;
        if(x > 0){
            var y = "a";
            console.log(x); //可以访问
            x = 6; //也可以访问
        }
        console.log(y); //不应该在这里再访问了。
    } 
       
如果用let的话，就会符合这个规则。
     
    if(true){
        let x = 5;
        if(x > 0){
            let y = "a";
            console.log(x); //可以访问
            x = 6; //也可以访问
        }
        console.log(y); //无法访问，报异常： Uncaught ReferenceError: y is not defined
    }      

[5] 作用域的父级的父级作用域的变量，该作用域里也可以访问，甚至无穷多级父的作用域里的变量都可以被访问，这种无穷多级的父，被称之为祖先

    
    if(true){
        var x = 5;
        if(x > 0){
            console.log(x); //可以访问
            for(var i = 0; i < x; i++){
                console.log(x); //也可以访问
            }
        }
    }
    
[6] 顶层作用域是所有作用域的祖先

函数的作用域类似，不过我们发现很多初学者无法区分函数作用域，所以下一页我们专门讲一下函数的作用域